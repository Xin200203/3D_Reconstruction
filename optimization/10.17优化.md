# 10.17 优化与实现计划（BiFusion + 2D 监督）

本文将当前讨论收敛为一组可执行、可验证的小任务（每个任务尽量原子化，便于逐一完成与回滚）。任务默认基于仓库现状：

- 编码器：`oneformer3d/bi_fusion_encoder_3dmv.py`（3DMV式 3D 融合）
- 投影：`oneformer3d/projection_utils.py`
- 主干/解码器：`oneformer3d/mixformer3d.py` + `oneformer3d/query_decoder.py`
- Hook/监控：`oneformer3d/enhanced_training_hook.py`、`oneformer3d/detailed_loss_hook.py`
- 配置：`configs/ESAM_CA/sv_bifusion_scannet200_3dmv.py`

维度契约（全程必须保持）：
- `conv3d_output_dim == pool.channel_proj == decoder.in_channels == 128`
- 点特征输入 decoder 时为 `3 + 128`

---

## TODO A：投影与栅格化（像素域）

目标：新增通用的点→像素栅格化工具，便于 2D 重建/2D 分割使用。

文件与接口：`oneformer3d/projection_utils.py`

任务 A1：新增 `splat_to_grid`
- 函数签名（建议）：
  - `def splat_to_grid(uv: Tensor, z: Tensor, feats: Tensor, valid: Tensor, H: int, W: int, mode: str = 'bilinear', depth_tol: float = 0.05) -> Tuple[Tensor, Tensor]:`
  - 输入：
    - `uv` (N,2) 像素坐标；`z` (N,) 深度；`feats` (N,C) 点特征；`valid` (N,) bool；尺寸 `(H,W)`。
  - 输出：
    - `F2D` (C,H,W)、`cover` (1,H,W)（累计权重/命中计数）。
- 模式：
  - `bilinear`：对四邻域分配权重；`cover` 累加分配权重。
  - `zbuf`：z‑buffer，保留最小 z；`cover` 为命中计数。
- 数值保护：空像素除零保护（`cover.clamp_min(ε)`），非法 `uv/valid=False` 跳过。

测试 A1（就地自测，提交前删除临时代码）：
- 在 `projection_utils.py` 最底部添加 `if __name__ == '__main__':` 的短测：随机生成点云、uv、feats，分别跑 bilinear/zbuf，断言输出形状与 `cover.sum()>0`；打印 `cover.mean()`。
- 运行：`python oneformer3d/projection_utils.py`，通过后将该自测块删除。

---

## TODO B：2D 像素头（重建/分割）与损失集成

目标：在不影响 decoder 的前提下，于 `mixformer3d.loss()` 中接入 2D 重建与 2D 分割损失（可按权重开关）。

文件：`oneformer3d/mixformer3d.py`

任务 B1：定义 2D 头（模块成员）
- 在 `ScanNet200MixFormer3D.__init__` 中新增：
  - `self.seg2d_head = nn.Sequential( nn.Conv2d(128, d_model, 1), nn.GroupNorm(8, d_model), nn.GELU(), nn.Conv2d(d_model, num_semantic_classes+1, 1) )`
  - `self.recon2d_head = nn.Sequential( nn.Conv2d(128, d_model, 1), nn.GroupNorm(8, d_model), nn.GELU(), nn.Conv2d(d_model, C_clip, 1) )`
    - 其中 `d_model` 可取 128；`C_clip` 从样本的 `clip_pix` 推断通道数（无则跳过重建）。
- 头部参数默认参与优化；不会影响已有路径。

任务 B2：在 `loss()` 中构建像素监督
- 对 batch 中每个样本：
  1. 从 `self._encoder_out` 取 `feat_fusion[i] (N_i,128)`、`valid_projection_mask[i] (N_i,)`；从 `batch_inputs_dict` 取 `points[i][:,:3]` 与 `cam_info[i]`。
  2. 用已有 `project_points_to_uv` 得到 `(uv, valid)` 与深度 `z`；与 `valid_projection_mask` 合并为最终 valid。
  3. 调用 `splat_to_grid` 得到 `F2D (128,60,80)` 与 `cover`。
  4. 2D 重建：若 `clip_pix` 存在（60×80），经 `recon2d_head` 得 `F2D_pred`，在 `Mcov=(cover≥τ)`（如 τ=1）∧ `Mmlm`（可先不启用）上计算 `loss_2d_recon_cos/mse` 与加权总和 `loss_2d_recon`；将其 `to(device)` 后写入 `losses`。
  5. 2D 分割（可开关）：用 z‑buffer/多数表决生成像素伪标 `y_hat` 与 `Mconf`；`seg2d_head(F2D)`→ `logits_2d`，在 `Mseg=Mcov∧Mconf` 上计算 `CE`（带 label smoothing、class_weight 可选），写入 `loss_2d_seg_ce`。
- 所有 2D 损失都应做“空掩码返回 0 张量”的保护，避免无覆盖导致的 NaN。

任务 B3：对齐损失接入（点级）
- 使用已有 `ClipConsCriterion`，但输入改为“对齐投影头后的点特征”（若暂未有，可先用 `feat3d_sparse.features` 与 `feat2d_sparse.features` 的简化版本，按 valid 掩码取交集）：
  - 调用：`loss_align = self.clip_criterion(list_of_feat3d_proj, list_of_feat2d_proj, valid_projection_mask)`；写入 `losses['loss_align']`。
- 若第一次集成复杂，可先保留现状（使用融合特征与 clip_global 的实现），待 C 组任务实现对齐投影头后替换。

任务 B4：监控值写入 `losses`
- 写入以下标量（`torch.as_tensor` 转 float32 且在当前 device）：
  - `supervised_pixel_ratio`（2D seg 有效像素/总像素）
  - `cover_mean`（`cover[Mcov]` 均值）
  - 若使用重建：`loss_2d_recon_cos/mse/loss_2d_recon`
  - 若使用分割：`loss_2d_seg_ce` 或 `loss_2d_seg_focal`

测试 B（最小运行自检）
- 构造一个伪 batch（1 个样本、少量点、伪 `clip_pix`）在 `loss()` 前部通过 `try/except` 分支生成最小张量，确保：
  - `splat_to_grid` 能返回形状正确的 `F2D/cover`
  - 2D 头的前向不报错，`losses` 中出现预期 key 且数值为张量
- 运行一次 `tools/train.py` 的单个迭代（可用超小数据/或 dry-run 开关）验证 `DetailedLossMonitorHook` 打印这些 key，然后删除自检代码。

---

## TODO C：对齐投影头（点级共享子空间）

目标：为点级 2D/3D 分支各自增加小型投影头，输出到相同维度 `D_align`，用于 `loss_align` 计算及监控 `cos_2d3d_mean_ln`。

文件：`oneformer3d/bi_fusion_encoder_3dmv.py`

任务 C1：增设投影头
- 在 `Conv3DFusionModule` 或 `BiFusionEncoder` 中，新增：
  - `self.proj3d = nn.Sequential(nn.Linear(64, D_align), nn.LayerNorm(D_align))`
  - `self.proj2d = nn.Sequential(nn.Linear(32, D_align), nn.LayerNorm(D_align))`
- 在 `_process_single` 中缓存对齐前的分支特征（已有 `_last_feats['f3d_feats'/'f2d_feats']`），在 forward 末尾通过 `encoder_out` 返回：
  - `encoder_out['proj_3d_points']`、`encoder_out['proj_2d_points']`（List[Tensor]，与 `feat_fusion` 对齐的 N×D_align）

任务 C2：在 `mixformer3d.loss()` 中替换对齐输入
- 用 `encoder_out['proj_3d_points']` 与 `encoder_out['proj_2d_points']` + `valid_projection_mask` 调用 `ClipConsCriterion`，写 `loss_align`。

测试 C：
- 打一小批数据，确认 `cos_2d3d_mean_ln` 随 `loss_align` 降低而上升（趋势检验）；日志中 2D/3D 范数比稳定。

---

## TODO D：Hook 监控增强（最小必要）

目标：记录 2D 相关的健康度、分组 LR、以及保持现有对齐监控。

文件：`oneformer3d/enhanced_training_hook.py`、`oneformer3d/detailed_loss_hook.py`

任务 D1：分组 LR 打印
- 在 `EnhancedTrainingHook._log_enhanced_stats` 前，将各 `param_groups` 的 `lr` 汇总写入 logger（或作为 scalar 至 visualizer）。命名：`lr/group{i}`。

任务 D2：2D 健康指标打印
- 在 `DetailedLossMonitorHook._build_loss_report` 中，若 `log_vars` 包含 `supervised_pixel_ratio/cover_mean`，纳入打印。

测试 D：
- 单步训练打印检查，确认新增 key 出现在日志中，无 KeyError。

---

## TODO E：配置与开关（安全默认）

目标：通过配置控制 2D 损失开启/权重，确保默认不破坏现有训练。

文件：`configs/ESAM_CA/sv_bifusion_scannet200_3dmv.py`

任务 E1：新增可选项
- 在 `model` 段 `decoder` 同级新增：
  - `two_d_losses = dict(enable_recon=False, enable_seg=False, w_recon=0.0, w_seg=0.0, w_align=0.0, recon_tau=1, seg_conf=0.6)`
- 在 `ScanNet200MixFormer3D.loss()` 读取此配置，按权重与开关计算/汇总损失（权重为 0 则跳过计算或返回 0 张量）。

测试 E：
- 以默认 False/0.0 运行一轮，确保训练行为与旧版一致（loss 数值与日志 key 一致）。

---

## TODO F：阶段化训练支持（可选，轻实现）

目标：为阶段B提供“2D门控 α(t) 与小权重 warmup” 的最简实现（不做复杂调度器）。

文件：`oneformer3d/bi_fusion_encoder_3dmv.py`、`oneformer3d/mixformer3d.py`

任务 F1：2D 门控 α(t)
- 在 `BiFusionEncoder` 中为 2D 分支输出乘以 `self.alpha_2d`（`nn.Parameter` 或 buffer），并提供 `set_alpha_2d(float)` 方法；默认 0.0。
- 在 `loss()` 中按迭代步或 epoch 简单线性升至 1.0（当 `two_d_losses.enable_*` 打开时）。

任务 F2：warmup 权重
- 在 `loss()` 中对 `w_align/w_recon/w_seg` 实施简单 warmup（如前 N_iter 线性从 0→配置权重），避免早期抖动。

测试 F：
- 日志观察 α 与各 loss 的生效比例是否按预期增长；验证阶段指标无异常。

---

## 备注与验收

- 每个 TODO 完成后，务必：
  - 运行最小单步/小 batch 自测，确认日志/损失键存在、数值为张量且无 NaN。
  - 若添加了 `__main__` 临时测试，测试通过后删除。
  - 保持维度契约（128/128/128）不被破坏；decoder 不应触发 `input_adapter` 分支。
- 若任一环节引起 `valid_projection_rate` 长期 < 0.3、`supervised_pixel_ratio` < 0.2、或 `norm_ratio_2d_over_3d` 越界，请回看对应 TODO 的实现与权重门控。

